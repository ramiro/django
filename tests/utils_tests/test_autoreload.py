import contextlib
import os
import py_compile
import shutil
import sys
import tempfile
import time
import types
import weakref
import zipfile
from importlib import import_module
from pathlib import Path
from unittest import mock, skipIf

from django.test import SimpleTestCase
from django.test.utils import extend_sys_path
from django.utils import autoreload

from .utils import on_macos_with_hfs


class TestIterModulesAndFiles(SimpleTestCase):
    def import_and_cleanup(self, name):
        import_module(name)
        self.addCleanup(lambda: sys.path_importer_cache.clear())
        self.addCleanup(lambda: sys.modules.pop(name, None))

    def clear_autoreload_caches(self):
        autoreload.iter_modules_and_files.cache_clear()

    def assertFileFound(self, filename):
        # Some temp directories are symlinks. Python resolves these fully while
        # importing.
        resolved_filename = filename.resolve()
        self.clear_autoreload_caches()
        # Test uncached access
        self.assertIn(resolved_filename, list(autoreload.iter_all_python_module_files()))
        # Test cached access
        self.assertIn(resolved_filename, list(autoreload.iter_all_python_module_files()))
        self.assertEqual(autoreload.iter_modules_and_files.cache_info().hits, 1)

    def assertFileNotFound(self, filename):
        resolved_filename = filename.resolve()
        self.clear_autoreload_caches()
        # Test uncached access
        self.assertNotIn(resolved_filename, list(autoreload.iter_all_python_module_files()))
        # Test cached access
        self.assertNotIn(resolved_filename, list(autoreload.iter_all_python_module_files()))
        self.assertEqual(autoreload.iter_modules_and_files.cache_info().hits, 1)

    def temporary_file(self, filename):
        dirname = tempfile.mkdtemp()
        self.addCleanup(shutil.rmtree, dirname)
        return Path(dirname) / filename

    def test_paths_are_pathlib_instances(self):
        for filename in autoreload.iter_all_python_module_files():
            self.assertIsInstance(filename, Path)

    def test_file_added(self):
        """
        When a file is added, it's returned by iter_all_python_module_files().
        """
        filename = self.temporary_file('test_deleted_removed_module.py')
        filename.touch()

        with extend_sys_path(str(filename.parent)):
            self.import_and_cleanup('test_deleted_removed_module')

        self.assertFileFound(filename.absolute())

    def test_check_errors(self):
        """
        When a file containing an error is imported in a function wrapped by
        check_errors(), gen_filenames() returns it.
        """
        filename = self.temporary_file('test_syntax_error.py')
        filename.write_text("Ceci n'est pas du Python.")

        with extend_sys_path(str(filename.parent)):
            with self.assertRaises(SyntaxError):
                autoreload.check_errors(import_module)('test_syntax_error')
        self.assertFileFound(filename)

    def test_check_errors_catches_all_exceptions(self):
        """
        Since Python may raise arbitrary exceptions when importing code,
        check_errors() must catch Exception, not just some subclasses.
        """
        filename = self.temporary_file('test_exception.py')
        filename.write_text('raise Exception')
        with extend_sys_path(str(filename.parent)):
            with self.assertRaises(Exception):
                autoreload.check_errors(import_module)('test_exception')
        self.assertFileFound(filename)

    def test_zip_reload(self):
        """
        Modules imported from zipped files have their archive location included
        in the result.
        """
        zip_file = self.temporary_file('zip_import.zip')
        with zipfile.ZipFile(str(zip_file), 'w', zipfile.ZIP_DEFLATED) as zipf:
            zipf.writestr('test_zipped_file.py', '')

        with extend_sys_path(str(zip_file)):
            self.import_and_cleanup('test_zipped_file')
        self.assertFileFound(zip_file)

    def test_bytecode_conversion_to_source(self):
        """.pyc and .pyo files are included in the files list."""
        filename = self.temporary_file('test_compiled.py')
        filename.touch()
        compiled_file = Path(py_compile.compile(str(filename), str(filename.with_suffix('.pyc'))))
        filename.unlink()
        with extend_sys_path(str(compiled_file.parent)):
            self.import_and_cleanup('test_compiled')
        self.assertFileFound(compiled_file)

    def test_weakref_in_sys_module(self):
        """iter_all_python_module_file() ignores weakref modules."""
        time_proxy = weakref.proxy(time)
        sys.modules['time_proxy'] = time_proxy
        self.addCleanup(lambda: sys.modules.pop('time_proxy', None))
        list(autoreload.iter_all_python_module_files())  # No crash.

    def test_module_without_spec(self):
        module = types.ModuleType('test_module')
        del module.__spec__
        self.assertEqual(autoreload.iter_modules_and_files((module,), frozenset()), frozenset())


class TestCommonRoots(SimpleTestCase):
    def test_common_roots(self):
        paths = (
            Path('/first/second'),
            Path('/first/second/third'),
            Path('/first/'),
            Path('/root/first/'),
        )
        results = autoreload.common_roots(paths)
        self.assertCountEqual(results, [Path('/first/'), Path('/root/first/')])


class TestSysPathDirectories(SimpleTestCase):
    def setUp(self):
        self._directory = tempfile.TemporaryDirectory()
        self.directory = Path(self._directory.name).resolve().absolute()
        self.file = self.directory / 'test'
        self.file.touch()

    def tearDown(self):
        self._directory.cleanup()

    def test_sys_paths_with_directories(self):
        with extend_sys_path(str(self.file)):
            paths = list(autoreload.sys_path_directories())
        self.assertIn(self.file.parent, paths)

    def test_sys_paths_non_existing(self):
        nonexistent_file = Path(self.directory.name) / 'does_not_exist'
        with extend_sys_path(str(nonexistent_file)):
            paths = list(autoreload.sys_path_directories())
        self.assertNotIn(nonexistent_file, paths)
        self.assertNotIn(nonexistent_file.parent, paths)

    def test_sys_paths_absolute(self):
        paths = list(autoreload.sys_path_directories())
        self.assertTrue(all(p.is_absolute() for p in paths))

    def test_sys_paths_directories(self):
        with extend_sys_path(str(self.directory)):
            paths = list(autoreload.sys_path_directories())
        self.assertIn(self.directory, paths)


class TestCheckErrors(SimpleTestCase):
    def test_mutates_error_files(self):
        fake_method = mock.MagicMock(side_effect=RuntimeError())
        wrapped = autoreload.check_errors(fake_method)
        with mock.patch.object(autoreload, '_error_files') as mocked_error_files:
            with self.assertRaises(RuntimeError):
                wrapped()
        self.assertEqual(mocked_error_files.append.call_count, 1)


class TestRaiseLastException(SimpleTestCase):
    @mock.patch('django.utils.autoreload._exception', None)
    def test_no_exception(self):
        # Should raise no exception if _exception is None
        autoreload.raise_last_exception()

    def test_raises_exception(self):
        class MyException(Exception):
            pass

        # Create an exception
        try:
            raise MyException('Test Message')
        except MyException:
            exc_info = sys.exc_info()

        with mock.patch('django.utils.autoreload._exception', exc_info):
            with self.assertRaisesMessage(MyException, 'Test Message'):
                autoreload.raise_last_exception()


class ReloaderTests(SimpleTestCase):
    RELOADER_CLS = None

    def setUp(self):
        self._tempdir = tempfile.TemporaryDirectory()
        self.tempdir = Path(self._tempdir.name).resolve().absolute()
        self.existing_file = self.ensure_file(self.tempdir / 'test.py')
        self.nonexistent_file = (self.tempdir / 'does_not_exist.py').absolute()
        self.reloader = self.RELOADER_CLS()

    def tearDown(self):
        self._tempdir.cleanup()
        self.reloader.stop()

    def ensure_file(self, path):
        path.parent.mkdir(exist_ok=True, parents=True)
        path.touch()
        # On Linux and Windows updating the mtime of a file using touch() will set a timestamp
        # value that is in the past, as the time value for the last kernel tick is used rather
        # than getting the correct absolute time.
        # To make testing simpler set the mtime to be the observed time when this function is
        # called.
        self.set_mtime(path, time.time())
        return path.absolute()

    def set_mtime(self, fp, value):
        os.utime(str(fp), (value, value))

    def increment_mtime(self, fp, by=1):
        current_time = time.time()
        self.set_mtime(fp, current_time + by)

    @contextlib.contextmanager
    def tick_twice(self):
        ticker = self.reloader.tick()
        next(ticker)
        yield
        next(ticker)


class IntegrationTests:
    @mock.patch('django.utils.autoreload.BaseReloader.notify_file_changed')
    @mock.patch('django.utils.autoreload.iter_all_python_module_files', return_value=frozenset())
    def test_file(self, mocked_modules, notify_mock):
        self.reloader.watch_file(self.existing_file)
        with self.tick_twice():
            self.increment_mtime(self.existing_file)
        self.assertEqual(notify_mock.call_count, 1)
        self.assertCountEqual(notify_mock.call_args[0], [self.existing_file])

    @mock.patch('django.utils.autoreload.BaseReloader.notify_file_changed')
    @mock.patch('django.utils.autoreload.iter_all_python_module_files', return_value=frozenset())
    def test_nonexistent_file(self, mocked_modules, notify_mock):
        self.reloader.watch_file(self.nonexistent_file)
        with self.tick_twice():
            self.ensure_file(self.nonexistent_file)
        self.assertEqual(notify_mock.call_count, 1)
        self.assertCountEqual(notify_mock.call_args[0], [self.nonexistent_file])

    @mock.patch('django.utils.autoreload.BaseReloader.notify_file_changed')
    @mock.patch('django.utils.autoreload.iter_all_python_module_files', return_value=frozenset())
    def test_nonexistent_file_in_non_existing_directory(self, mocked_modules, notify_mock):
        non_existing_directory = self.tempdir / 'non_existing_dir'
        nonexistent_file = non_existing_directory / 'test'
        self.reloader.watch_file(nonexistent_file)
        with self.tick_twice():
            self.ensure_file(nonexistent_file)
        self.assertEqual(notify_mock.call_count, 1)
        self.assertCountEqual(notify_mock.call_args[0], [nonexistent_file])

    @mock.patch('django.utils.autoreload.BaseReloader.notify_file_changed')
    @mock.patch('django.utils.autoreload.iter_all_python_module_files', return_value=frozenset())
    def test_glob(self, mocked_modules, notify_mock):
        non_py_file = self.ensure_file(self.tempdir / 'non_py_file')
        self.reloader.watch_dir(self.tempdir, '*.py')
        with self.tick_twice():
            self.increment_mtime(non_py_file)
            self.increment_mtime(self.existing_file)
        self.assertEqual(notify_mock.call_count, 1)
        self.assertCountEqual(notify_mock.call_args[0], [self.existing_file])

    @mock.patch('django.utils.autoreload.BaseReloader.notify_file_changed')
    @mock.patch('django.utils.autoreload.iter_all_python_module_files', return_value=frozenset())
    def test_glob_non_existing_directory(self, mocked_modules, notify_mock):
        non_existing_directory = self.tempdir / 'does_not_exist'
        nonexistent_file = non_existing_directory / 'test.py'
        self.reloader.watch_dir(non_existing_directory, '*.py')
        with self.tick_twice():
            self.ensure_file(nonexistent_file)
            self.set_mtime(nonexistent_file, time.time())
        self.assertEqual(notify_mock.call_count, 1)
        self.assertCountEqual(notify_mock.call_args[0], [nonexistent_file])

    @mock.patch('django.utils.autoreload.BaseReloader.notify_file_changed')
    @mock.patch('django.utils.autoreload.iter_all_python_module_files', return_value=frozenset())
    def test_multiple_globs(self, mocked_modules, notify_mock):
        self.ensure_file(self.tempdir / 'x.test')
        self.reloader.watch_dir(self.tempdir, '*.py')
        self.reloader.watch_dir(self.tempdir, '*.test')
        with self.tick_twice():
            self.increment_mtime(self.existing_file)
        self.assertEqual(notify_mock.call_count, 1)
        self.assertCountEqual(notify_mock.call_args[0], [self.existing_file])

    @mock.patch('django.utils.autoreload.BaseReloader.notify_file_changed')
    @mock.patch('django.utils.autoreload.iter_all_python_module_files', return_value=frozenset())
    def test_overlapping_globs(self, mocked_modules, notify_mock):
        self.reloader.watch_dir(self.tempdir, '*.py')
        self.reloader.watch_dir(self.tempdir, '*.p*')
        with self.tick_twice():
            self.increment_mtime(self.existing_file)
        self.assertEqual(notify_mock.call_count, 1)
        self.assertCountEqual(notify_mock.call_args[0], [self.existing_file])

    @mock.patch('django.utils.autoreload.BaseReloader.notify_file_changed')
    @mock.patch('django.utils.autoreload.iter_all_python_module_files', return_value=frozenset())
    def test_glob_recursive(self, mocked_modules, notify_mock):
        non_py_file = self.ensure_file(self.tempdir / 'dir' / 'non_py_file')
        py_file = self.ensure_file(self.tempdir / 'dir' / 'file.py')
        self.reloader.watch_dir(self.tempdir, '**/*.py')
        with self.tick_twice():
            self.increment_mtime(non_py_file)
            self.increment_mtime(py_file)
        self.assertEqual(notify_mock.call_count, 1)
        self.assertCountEqual(notify_mock.call_args[0], [py_file])

    @mock.patch('django.utils.autoreload.BaseReloader.notify_file_changed')
    @mock.patch('django.utils.autoreload.iter_all_python_module_files', return_value=frozenset())
    def test_multiple_recursive_globs(self, mocked_modules, notify_mock):
        non_py_file = self.ensure_file(self.tempdir / 'dir' / 'test.txt')
        py_file = self.ensure_file(self.tempdir / 'dir' / 'file.py')
        self.reloader.watch_dir(self.tempdir, '**/*.txt')
        self.reloader.watch_dir(self.tempdir, '**/*.py')
        with self.tick_twice():
            self.increment_mtime(non_py_file)
            self.increment_mtime(py_file)
        self.assertEqual(notify_mock.call_count, 2)
        self.assertCountEqual(notify_mock.call_args_list, [mock.call(py_file), mock.call(non_py_file)])

    @mock.patch('django.utils.autoreload.BaseReloader.notify_file_changed')
    @mock.patch('django.utils.autoreload.iter_all_python_module_files', return_value=frozenset())
    def test_nested_glob_recursive(self, mocked_modules, notify_mock):
        inner_py_file = self.ensure_file(self.tempdir / 'dir' / 'file.py')
        self.reloader.watch_dir(self.tempdir, '**/*.py')
        self.reloader.watch_dir(inner_py_file.parent, '**/*.py')
        with self.tick_twice():
            self.increment_mtime(inner_py_file)
        self.assertEqual(notify_mock.call_count, 1)
        self.assertCountEqual(notify_mock.call_args[0], [inner_py_file])

    @mock.patch('django.utils.autoreload.BaseReloader.notify_file_changed')
    @mock.patch('django.utils.autoreload.iter_all_python_module_files', return_value=frozenset())
    def test_overlapping_glob_recursive(self, mocked_modules, notify_mock):
        py_file = self.ensure_file(self.tempdir / 'dir' / 'file.py')
        self.reloader.watch_dir(self.tempdir, '**/*.p*')
        self.reloader.watch_dir(self.tempdir, '**/*.py*')
        with self.tick_twice():
            self.increment_mtime(py_file)
        self.assertEqual(notify_mock.call_count, 1)
        self.assertCountEqual(notify_mock.call_args[0], [py_file])


class BaseReloaderTests(ReloaderTests):
    RELOADER_CLS = autoreload.BaseReloader

    def test_watch_without_absolute(self):
        with self.assertRaisesMessage(ValueError, 'test.py must be absolute.'):
            self.reloader.watch_file('test.py')

    def test_watch_with_single_file(self):
        self.reloader.watch_file(self.existing_file)
        watched_files = list(self.reloader.watched_files())
        self.assertIn(self.existing_file, watched_files)

    def test_watch_with_glob(self):
        self.reloader.watch_dir(self.tempdir, '*.py')
        watched_files = list(self.reloader.watched_files())
        self.assertIn(self.existing_file, watched_files)

    def test_watch_files_with_recursive_glob(self):
        inner_file = self.ensure_file(self.tempdir / 'test' / 'test.py')
        self.reloader.watch_dir(self.tempdir, '**/*.py')
        watched_files = list(self.reloader.watched_files())
        self.assertIn(self.existing_file, watched_files)
        self.assertIn(inner_file, watched_files)

    def test_run_loop_catches_stopiteration(self):
        def mocked_tick():
            yield

        with mock.patch.object(self.reloader, 'tick', side_effect=mocked_tick) as tick:
            self.reloader.run_loop()
        self.assertEqual(tick.call_count, 1)

    def test_run_loop_stop_and_return(self):
        def mocked_tick(*args):
            yield
            self.reloader.stop()
            return  # Raises StopIteration

        with mock.patch.object(self.reloader, 'tick', side_effect=mocked_tick) as tick:
            self.reloader.run_loop()

        self.assertEqual(tick.call_count, 1)


@skipIf(on_macos_with_hfs(), "These tests do not work with HFS+ as a filesystem")
class StatReloaderTests(ReloaderTests, IntegrationTests):
    RELOADER_CLS = autoreload.StatReloader

    def setUp(self):
        super().setUp()
        # Shorten the sleep time to speed up tests.
        self.reloader.SLEEP_TIME = 0.01

    def test_snapshot_files_ignores_missing_files(self):
        with mock.patch.object(self.reloader, 'watched_files', return_value=[self.nonexistent_file]):
            self.assertEqual(dict(self.reloader.snapshot_files()), {})

    def test_snapshot_files_updates(self):
        with mock.patch.object(self.reloader, 'watched_files', return_value=[self.existing_file]):
            snapshot1 = dict(self.reloader.snapshot_files())
            self.assertIn(self.existing_file, snapshot1)
            self.increment_mtime(self.existing_file)
            snapshot2 = dict(self.reloader.snapshot_files())
            self.assertNotEqual(snapshot1[self.existing_file], snapshot2[self.existing_file])

    def test_does_not_fire_without_changes(self):
        with mock.patch.object(self.reloader, 'watched_files', return_value=[self.existing_file]), \
                mock.patch.object(self.reloader, 'notify_file_changed') as notifier:
            mtime = self.existing_file.stat().st_mtime
            initial_snapshot = {self.existing_file: mtime}
            second_snapshot = self.reloader.loop_files(initial_snapshot, time.time())
            self.assertEqual(second_snapshot, {})
            notifier.assert_not_called()

    def test_fires_when_created(self):
        with mock.patch.object(self.reloader, 'watched_files', return_value=[self.nonexistent_file]), \
                mock.patch.object(self.reloader, 'notify_file_changed') as notifier:
            self.nonexistent_file.touch()
            mtime = self.nonexistent_file.stat().st_mtime
            second_snapshot = self.reloader.loop_files({}, mtime - 1)
            self.assertCountEqual(second_snapshot.keys(), [self.nonexistent_file])
            notifier.assert_called_once_with(self.nonexistent_file)

    def test_fires_with_changes(self):
        with mock.patch.object(self.reloader, 'watched_files', return_value=[self.existing_file]), \
                mock.patch.object(self.reloader, 'notify_file_changed') as notifier:
            initial_snapshot = {self.existing_file: 1}
            second_snapshot = self.reloader.loop_files(initial_snapshot, time.time())
            notifier.assert_called_once_with(self.existing_file)
            self.assertCountEqual(second_snapshot.keys(), [self.existing_file])
